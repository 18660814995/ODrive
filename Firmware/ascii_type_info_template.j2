/*[# This is the original template, thus the warning below does not apply to this file #]
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains support functions for the ODrive ASCII protocol.
 *
 * TODO: might generalize this as an approach to runtime introspection.
 */


class TypeInfo;

struct PropertyInfo {
    const char * name;
    void*(*getter)(void*);
    TypeInfo* type_info;
};

class TypeInfo {
public:
    TypeInfo(const PropertyInfo* property_table, size_t property_table_length)
        : property_table_(property_table), property_table_length_(property_table_length) {}
    
    //virtual bool read_string(void* ctx) { return false; };
    //virtual bool write_string(void* ctx) { return false; };

    const PropertyInfo* get_property_info(const char * name, size_t length) {
        for (const PropertyInfo* prop = property_table_; prop < (property_table_ + property_table_length_); ++prop) {
            if (!strncmp(name, prop->name, length)) {
                return prop;
            }
        }
        return nullptr;
    }

private:
    const PropertyInfo* property_table_;
    size_t property_table_length_;
};


class Introspectable {
public:
    Introspectable(void* obj, TypeInfo* type_info) : obj_(obj), type_info_(type_info) {}

    Introspectable get_child(const char * path, size_t length) {
        Introspectable current = *this;

        const char * begin = path;
        const char * end = path + length;

        while ((begin < end) && current.obj_ && current.type_info_) {
            const char * end_of_token = std::find(begin, end, '.');
            const PropertyInfo* prop_info = current.type_info_->get_property_info(begin, end_of_token - begin);
            if (prop_info) {
                current = Introspectable{(*prop_info->getter)(obj_), prop_info->type_info};
            } else {
                current = Introspectable{nullptr, nullptr};
            }
            begin = std::min(end, end_of_token + 1);
        }

        return current;
    };

private:
    void* obj_;
    TypeInfo* type_info_;
};

[% for intf in interfaces.values() %]

template<typename T>
struct [[intf.fullname | to_pascal_case]]TypeInfo : TypeInfo {
    static const PropertyInfo property_table[];
    static const TypeInfo singleton;
};

template<typename T>
const PropertyInfo [[intf.name | to_pascal_case]]TypeInfo<T>::property_table[] = {
[%- for property in intf.attributes.values() %]
    {"[[property.name]]", [](void* obj){ return (void*)static_cast<[[property.type.c_type]]*>(&((T*)obj)->[[property.name | to_snake_case]]); }, [[property.type.fullname | to_pascal_case]]TypeInfo<decltype(std::declval<T>().[[property.name | to_snake_case]])>::singleton},
[%- endfor %]
};
template<typename T>
const TypeInfo [[intf.fullname | to_pascal_case]]TypeInfo<T>::singleton{[[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table, sizeof([[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table) / sizeof([[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table[0])};

[% endfor %]
